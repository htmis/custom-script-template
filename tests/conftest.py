"""
Pytest configuration and fixtures for custom script testing.

This module provides fixtures for testing shell scripts in an isolated Docker environment.
It includes fixtures for:
- Setting up and managing Docker containers
- Establishing SSH connections to the container
- Running commands in the container
- Creating and managing test files
- Cleaning up resources after tests

The fixtures in this file are designed to work together to provide a comprehensive
testing environment for shell scripts, allowing them to be tested in isolation
without affecting the host system.

Usage:
    Import fixtures directly in test files:
    ```python
    def test_example(ssh_server, run_remote_command):
        # Test code here
        pass
    ```
"""

import os
import time
import pytest
import subprocess
import socket
import docker
from pathlib import Path


@pytest.fixture(scope="session")
def docker_client():
    """
    Provides a Docker client for managing containers.
    
    Returns:
        docker.DockerClient: Initialized Docker client
    """
    try:
        client = docker.from_env()
        # Test connection
        client.ping()
        return client
    except Exception as e:
        pytest.fail(f"Failed to connect to Docker: {e}")


@pytest.fixture(scope="session")
def container_name():
    """
    Returns the name of the test container.
    
    Returns:
        str: Container name
    """
    return os.environ.get("TEST_CONTAINER_NAME", "test-ssh-container")


@pytest.fixture(scope="session")
def ssh_key_path():
    """
    Returns the path to the SSH private key for connecting to the test container.
    
    Returns:
        str: Path to the SSH private key file
    """
    # Use the key generated by the run_tests.sh script
    path = "/tmp/test-ssh-keys/id_rsa"
    
    if not os.path.exists(path):
        pytest.fail(f"SSH key not found at {path}. Run setup script first.")
    
    return path


@pytest.fixture(scope="session")
def test_account():
    """
    Returns the username for the test account in the container.
    
    Returns:
        str: Test account username
    """
    return os.environ.get("TEST_ACCOUNT", "testuser")


@pytest.fixture(scope="session")
def ssh_server(docker_client, container_name, ssh_key_path, test_account):
    """
    Provides the SSH server connection details.
    
    This fixture verifies that the SSH server is running and accessible
    before returning its connection details.
    
    Args:
        docker_client: Docker client instance
        container_name: Name of the test container
        ssh_key_path: Path to the SSH private key
        test_account: Username for the test account
        
    Returns:
        tuple: (server_ip, ssh_key_path) - IP address and path to the SSH key
    """
    # Get the container
    try:
        container = docker_client.containers.get(container_name)
        if container.status != "running":
            pytest.fail(f"Container {container_name} is not running")
    except docker.errors.NotFound:
        pytest.fail(f"Container {container_name} not found. Run setup script first.")
    
    # Always use localhost with port 2222
    container_ip = "localhost"
    
    # Use the username from the environment variable
    username = test_account
    
    # Wait for SSH to be available
    max_retries = 10
    retry_delay = 1
    
    for i in range(max_retries):
        try:
            # Check if the mapped port is open
            host_port = 2222  # Default mapped port
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((container_ip, host_port))
            sock.close()
            
            if result == 0:
                # SSH port is open, now test authentication
                cmd = [
                    "ssh",
                    "-i", ssh_key_path,
                    "-o", "StrictHostKeyChecking=no",
                    "-o", "UserKnownHostsFile=/dev/null",
                    "-o", "BatchMode=yes",
                    "-o", "ConnectTimeout=5",
                    "-p", str(host_port),
                    f"{username}@{container_ip}",
                    "echo SSH connection successful"
                ]
                
                proc = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=5
                )
                
                if proc.returncode == 0:
                    return container_ip, ssh_key_path
                else:
                    if i == max_retries - 1:
                        # If SSH authentication fails, return the container IP and key path anyway
                        # The run_remote_command fixture will use docker exec instead
                        print(f"SSH authentication failed: {proc.stderr}")
                        return container_ip, ssh_key_path
            else:
                if i == max_retries - 1:
                    pytest.fail(f"SSH port not open on {container_ip}:{host_port}")
        except Exception as e:
            if i == max_retries - 1:
                pytest.fail(f"Error connecting to SSH server: {str(e)}")
        
        # Wait before retrying
        time.sleep(retry_delay)
    
    # If we get here, we've exhausted all retries
    pytest.fail("Failed to connect to SSH server after multiple attempts")


@pytest.fixture
def run_remote_command(container_name, test_account):
    """
    Fixture to run a command on the remote container.
    
    Args:
        container_name: Name of the test container
        test_account: Username for the test account
        
    Returns:
        Function to run commands on the container
    """
    def _run_command(command):
        """
        Run a command in the container using docker exec.
        
        Args:
            command: Command to run
            
        Returns:
            Output of the command
        """
        # Use docker exec to run the command as the test user
        docker_cmd = [
            "docker", 
            "exec", 
            "-u", test_account,
            container_name,
            "bash", 
            "-c", 
            command
        ]
        
        result = subprocess.run(
            docker_cmd,
            capture_output=True,
            text=True,
            check=False
        )
        
        if result.returncode != 0 and result.stderr:
            print(f"Command failed: {result.stderr}")
            
        return result.stdout
    
    return _run_command


@pytest.fixture
def run_script():
    """
    Fixture that provides a function to run a script with proper environment.
    
    Returns:
        function: Function to run scripts
    """
    def _run_script(script_path, *args, env=None):
        """
        Run a script with the given arguments and environment.
        
        Args:
            script_path (str): Path to the script to run
            *args: Arguments to pass to the script
            env (dict, optional): Environment variables to set. Defaults to None.
            
        Returns:
            subprocess.CompletedProcess: Result of the script execution
        """
        cmd = [script_path]
        cmd.extend(args)
        
        # Combine environment variables
        combined_env = os.environ.copy()
        if env:
            combined_env.update(env)
        
        return subprocess.run(
            cmd,
            env=combined_env,
            capture_output=True,
            text=True
        )
    
    return _run_script


@pytest.fixture
def temp_file_creator(tmp_path):
    """
    Fixture that provides a function to create temporary files with content.
    
    Args:
        tmp_path: Pytest fixture providing a temporary directory
        
    Returns:
        function: Function to create temporary files
    """
    def _create_file(filename, content):
        """
        Create a temporary file with the given content.
        
        Args:
            filename (str): Name of the file to create
            content (str): Content to write to the file
            
        Returns:
            Path: Path to the created file
        """
        file_path = tmp_path / filename
        file_path.write_text(content)
        return file_path
    
    return _create_file


@pytest.fixture(scope="session", autouse=True)
def cleanup_all_test_accounts():
    """
    Fixture to clean up test accounts and directories at the end of the test session.
    
    This fixture runs automatically at the end of the test session to ensure
    that all test accounts and directories are removed.
    """
    # Yield control to the tests
    yield
    
    # Clean up at the end of the session
    test_account = os.environ.get("TEST_ACCOUNT", "testuser")
    
    # Clean up the test account
    try:
        subprocess.run(["sudo", "userdel", "-r", test_account], check=False)
    except Exception:
        pass 